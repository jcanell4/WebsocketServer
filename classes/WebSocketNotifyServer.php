<?php

//ALERTA[Xavi] Afegits
if (!defined("DOKU_INC")) {
    define('DOKU_INC', dirname(__FILE__) . '/../../../../');
}
if (!defined('DOKU_PLUGIN')) {
    define('DOKU_PLUGIN', DOKU_INC . 'lib/plugins/');
}

if (!defined('WIKI_IOC_MODEL')) {
    define('WIKI_IOC_MODEL', DOKU_INC . "lib/plugins/wikiiocmodel/");
}

require_once DOKU_INC . 'inc/init.php'; // ALERTA[avi] És necessari?
require_once DOKU_PLUGIN . 'wikiiocmodel/persistence/BasicPersistenceEngine.php';
require_once DOKU_PLUGIN . "wikiiocmodel/datamodel/WebsocketNotifyModel.php";
require_once DOKU_PLUGIN . "wikiiocmodel/WikiIocInfoManager.php";

// ALERTA[Xavi] Fi afegits

require_once('./WebSocketServer.php');


class WebSocketNotifyServer extends WebSocketServer
{
    //ALERTA[Xavi] Afegit
    private $notifyModel;

    public function __construct() {
        $port = WikiGlobalConfig::getConf('notifier_ws_port', 'wikiiocmodel');
        $addr = WikiGlobalConfig::getConf('notifier_ws_ip', 'wikiiocmodel');

        parent::__construct($addr, $port);
    }

    //protected $maxBufferSize = 1048576; //1MB... overkill for an echo server, but potentially plausible for other applications.

    protected function process($user, $message)
    {
        $this->send($user, $message);
    }

    protected function connected($user)
    {
        // Do nothing: This is just an echo server, there's no need to track the user.
        // However, if we did care about the users, we would probably have a cookie to
        // parse at this step, would be looking them up in permanent storage, etc.
    }

    protected function closed($user)
    {
        // Do nothing: This is where cleanup would go, in case the user had any sort of
        // open files or other objects associated with them.  This runs after the socket
        // has been closed, so there is no need to clean up the socket itself here.
    }

    protected function startServer($addr, $port, $bufferLength)
    {
        parent::startServer($addr, $port, $bufferLength); // TODO: Change the autogenerated stub

        // Instanciem un DokuNotifyModel
        $this->notifyModel = new WebsocketNotifyModel(new BasicPersistenceEngine());

    }

    protected function send($user, $message)
    {
        echo $message;

        // Comprovem els mots
        $mots = explode(" ", $message);

        $command = array_shift($mots);

        if ($command === 'get') {

            $message = $this->getting($mots);
        } else if ($command === 'add') {
            $message = $this->adding($mots);
        }


        if ($user->handshake) {
            $message = $this->frame($message, $user);
            @socket_write($user->socket, $message, strlen($message));
        } else {
            // User has not yet performed their handshake.  Store for sending later.
            $holdingMessage = array('user' => $user, 'message' => $message);
            $this->heldMessages[] = $holdingMessage;
        }

        var_dump($message);
    }

    private function getting($mots)
    {
        // TODO[Xavi] carregar el DokuNotifyModel i fer un popMessages(false) per no esborrar
        $userId = $mots[0];

        $result = json_encode($this->notifyModel->popNotifications($userId));

        return $result;
    }

    private function adding($mots)
    {
        // TODO[Xavi] carregar el DokuNotifyModel i fer un add() per afegir missatge

        $text = $mots[0];
        $receiverId = $mots[1];

        // TODO[Xavi] s'hauria de refinar la descomposició dels mots per poder utilitzar els arrays
        $params = [];
        $senderId = WikiIocInfoManager::getInfo('userinfo')['name'];

        $this->notifyModel->notifyToFrom($text, $receiverId, $params, $senderId);
        return 'Enviat OK';
    }
}


